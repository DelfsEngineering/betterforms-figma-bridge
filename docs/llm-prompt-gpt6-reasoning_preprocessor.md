# Figma to BetterForms Schema - Preprocessing Polish (GPT-6 Reasoning)

You are receiving a **draft BetterForms schema** generated by a JavaScript preprocessor. Polish and complete the conversion by addressing flagged issues and adding semantic improvements.

---

## Input Structure

```json
{
  "data": [...],              // Original Figma data (for context)
  "preprocessing": {
    "draftSchema": {...},     // Preprocessed schema (your starting point)
    "meta": {
      "issues": [             // What needs your attention
        "No autolayout on 'Card' - determine positioning",
        "IMAGE fill on 'Avatar' - convert to <img> tag"
      ]
    }
  }
}
```

---

<instructions>

## Task Overview

Your job is to:
1. **Fix all flagged issues** in the `meta.issues` array
2. **Add semantic improvements** (better naming, accessibility, HTML semantics)
3. **Preserve working conversions** from the draft schema
4. **Return only valid JSON** (no explanations, no markdown)

## BetterForms Field Types

### `type: "group"` - Containers
Use for frames, sections, layout containers. Has `fields` array for children.

```json
{
  "type": "group",
  "styleClasses": "flex flex-col gap-4 p-6 bg-white rounded-lg",
  "fields": [/* child elements */],
  "attributes": {
    "formGroup": {
      "data-idbf": "idbf_g_60_123"
    }
  },
  "BFName": "card_container"
}
```

### `type: "html"` - Custom HTML Content
Use for text, images, SVG graphics, shapes, custom form controls - anything not a button/input.

**Text example:**
```json
{
  "type": "html",
  "html": "<h1 class=\"text-2xl font-bold\">Welcome</h1>",
  "styleClasses": "mb-4",
  "attributes": {
    "formElement": {
      "data-idbf": "idbf_e_60_124"
    }
  },
  "BFName": "welcome_heading"
}
```

**SVG example:**
```json
{
  "type": "html",
  "html": "<svg width=\"24\" height=\"24\">...</svg>",
  "styleClasses": "w-6 h-6",
  "attributes": {
    "formElement": {
      "data-idbf": "idbf_e_60_125"
    }
  },
  "BFName": "icon_star"
}
```

**Common patterns:**
- Text: `<h1>`, `<h2>`, `<p>`, `<span>`
- Quotes: `<blockquote class="border-l-4 border-gray-300 pl-4"><p>...</p></blockquote>` (always add left border styling)
- SVG graphics: `<svg>...</svg>` (already converted by preprocessor - preserve as-is)
- Images: `<img src="..." alt="..." class="...">`
- Gradients: `<div style="background: linear-gradient(...)"></div>`
- Custom controls: `<label><input type="checkbox" ...><span>...</span></label>`

### `type: "button"` - Interactive Buttons

**Required properties:** `text` (or `icon`), `buttonClasses`, `actions`, `styleClasses: "mb-0"`

**üö® IMPORTANT:** Margin must go in `styleClasses`, NOT in `buttonClasses`!

```json
{
  "type": "button",
  "text": "Submit",
  "buttonClasses": "px-4 py-2 bg-blue-600 text-white rounded",  // Visual styling only
  "actions": [],
  "styleClasses": "mb-0",  // ‚úÖ Margin goes here!
  "attributes": {"formElement": {"data-idbf": "idbf_e_60_126"}},
  "BFName": "submit_button"
}
```

**Icon button:**
```json
{"type": "button", "icon": "fa-regular fa-edit", "text": "", "actions": [], "buttonClasses": "p-[4px] w-[28px] h-[28px] rounded text-[#0c4a6e]", "styleClasses": "mb-0"}
```

### `type: "input"` / `type: "textArea"` - Form Inputs
**Use sparingly.** Only for simple text inputs. For checkboxes, radios, toggles ‚Üí use `type: "html"` with custom markup.

## Required Properties

Every field MUST have:
- `type` - One of: group, html, button, input, textArea
- `attributes` - **MUST be wrapped in `formGroup` (for groups) or `formElement` (for elements)**
- `BFName` - lowercase_with_underscores, max 50 chars, descriptive

### ‚ö†Ô∏è CRITICAL: `attributes` Structure

**BetterForms requires `data-idbf` to be wrapped in `formGroup` or `formElement`:**

‚úÖ **CORRECT for groups:**
```json
"attributes": {
  "formGroup": {
    "data-idbf": "idbf_g_abc123"
  }
}
```

‚úÖ **CORRECT for elements (html, button, input, textArea):**
```json
"attributes": {
  "formElement": {
    "data-idbf": "idbf_e_abc123"
  }
}
```

‚úÖ **With additional data attributes (like font-family):**
```json
"attributes": {
  "formElement": {
    "data-idbf": "idbf_e_abc123",
    "data-figma-font": "Helvetica"
  }
}
```

**Note:** `data-figma-font` tells you the original font. Use it appropriately:
- **"Font Awesome"** ‚Üí Convert ligature to icon class: `"edit"` ‚Üí `<i class="fa-regular fa-edit"></i>`
- **Regular fonts** ‚Üí Apply as inline style: `style="font-family: Helvetica, Arial, sans-serif"`
- **Always preserve** the `data-figma-font` attribute in output

‚ùå **WRONG - Missing wrapper:**
```json
"attributes": { "data-idbf": "idbf_e_abc123" }
```

**Note:** The preprocessor outputs flat `data-idbf` attributes. Your job is to wrap them in the correct `formGroup` or `formElement` object based on the element type.

</instructions>

---

<exploration>

## Using Figma Data for Context

The raw Figma data is provided for context when fixing issues. Use it to:

1. **For layout issues:** Analyze `absoluteTransform` arrays to determine positioning patterns
2. **For image issues:** Confirm `fills[].type === "IMAGE"` and get sizing
3. **For gradient issues:** Extract `fills[]` gradient data (stops, colors, transform)
4. **For semantic improvements:** Use `node.name` to infer purpose (e.g., "Hero Section", "CTA Button")

**Do not guess or invent values.** If the Figma data doesn't provide sufficient information for a fix, use reasonable defaults:
- **Images** ‚Üí Use real placeholder URLs (NEVER use empty/broken src):
  - Avatars: `https://i.pravatar.cc/{size}` (e.g., 40, 100, 200)
  - Generic: `https://source.unsplash.com/random/{width}x{height}`
  - Solid color: `https://placehold.co/{width}x{height}/png`
- **Gradients** ‚Üí Simple two-color linear gradients
- **Layouts** ‚Üí Flex-based layouts as fallback

</exploration>

---

<fix_patterns>

## Issue Resolution Patterns

### Issue Type 1: No Autolayout

**Pattern:** `"No autolayout on '[Name]' - LLM should determine positioning strategy"`

**Cause:** Figma node has `direction: "NONE"` - children are manually positioned.

**Resolution steps:**
1. Examine `absoluteTransform` for each child in Figma data
2. Calculate implicit padding from child positions:
   - If ALL children have same X offset from parent ‚Üí add `pl-[Xpx]`
   - If ALL children have same Y offset from parent ‚Üí add `pt-[Ypx]`
   - If uniform on all sides ‚Üí use `p-[Xpx]`
3. Determine layout pattern:
   - Similar Y coords ‚Üí `flex flex-row`
   - Similar X coords ‚Üí `flex flex-col`
   - Grid alignment ‚Üí `grid grid-cols-N`
   - Overlapping ‚Üí `relative` parent + `absolute` children
4. Remove fixed height if content should flow naturally (use `min-h-[...]` instead)
5. Add child-specific positioning if needed

**Example - Testimonial Card:**
```json
// Figma Data Analysis:
// - Card: X=2609, Y=2285, Size: 360√ó404
// - Star Rating: X=2641, Y=2317 ‚Üí Offset: (32, 32)
// - Quote: X=2641, Y=2365 ‚Üí Offset: (32, 80)
// - People: X=2641, Y=2617 ‚Üí Offset: (32, 332)
// Pattern: All children 32px from left edge = implicit padding!

// Before (preprocessor output):
{"type": "group", "styleClasses": "w-[360px] h-[404px] bg-white rounded-[30px]", "fields": [...]}

// After (LLM adds layout + padding):
{"type": "group", "styleClasses": "w-[360px] bg-white rounded-[30px] flex flex-col gap-6 p-8", "fields": [...]}
// Changes:
// - Added: flex flex-col gap-6 (vertical layout)
// - Added: p-8 (32px ‚âà 2rem implicit padding)
// - Removed: h-[404px] (let content flow naturally)

// ‚ö†Ô∏è IMPORTANT: Child elements should NOT have margin-top/margin-bottom when parent has gap-X
// The gap property handles all spacing between children automatically!
```

---

### Issue Type 2: IMAGE Fills

**Pattern:** `"IMAGE fill on '[Name]' - LLM should convert to <img> or background-image"`

**Cause:** Node has `fill.type: "IMAGE"` - preprocessor cannot access image URL.

**Resolution:**
Replace placeholder HTML with `<img>` tag using proper placeholder image URLs:

**For portraits/avatars:**
```json
// Before:
{"type": "html", "html": "<!-- RECTANGLE: Avatar -->", "styleClasses": "w-[40px] h-[40px] rounded-[36px]"}

// After:
{"type": "html", "html": "<img src=\"https://i.pravatar.cc/40\" alt=\"User avatar\" class=\"w-full h-full object-cover\">", "styleClasses": "w-[40px] h-[40px] rounded-[36px] overflow-hidden", "attributes": {"formElement": {"data-idbf": "idbf_e_60_836"}}, "BFName": "user_avatar"}
```

**For generic images:**
```json
// Use Unsplash for realistic placeholders
{"type": "html", "html": "<img src=\"https://source.unsplash.com/random/400x300\" alt=\"Decorative image\" class=\"w-full h-full object-cover\">", "styleClasses": "w-[400px] h-[300px] rounded-lg overflow-hidden"}
```

**Placeholder Image Services:**
- **Avatars/portraits:** `https://i.pravatar.cc/{size}` or `https://api.dicebear.com/7.x/avataaars/svg`
- **Generic images:** `https://source.unsplash.com/random/{width}x{height}`
- **Solid color placeholders:** `https://placehold.co/{width}x{height}/png`

**Always:**
- Add `overflow-hidden` to styleClasses for rounded images
- Use `class="w-full h-full object-cover"` inside the `<img>` tag
- Add descriptive `alt` text

---

### Issue Type 3: Background SVG/Gradients with Overlaid Content

**Pattern:** Large background SVG/gradient with text/buttons overlaid on top

**Preferred Approach - Natural Stacking Order:**
```json
{
  "type": "group",
  "BFName": "cta_section",
  "styleClasses": "relative w-[1440px] h-[420px] flex flex-col items-center justify-center gap-6 px-8 mb-0",
  "fields": [
    {
      "BFName": "cta_background_svg",
      "html": "<svg>...gradient...</svg>",
      "styleClasses": "absolute inset-0 w-full h-full mb-0",  // First child = background
      "type": "html"
    },
    {"html": "<h2>Heading</h2>", "styleClasses": "... mb-0"},  // Naturally above (comes after)
    {"html": "<p>Text</p>", "styleClasses": "... mb-0"}
  ]
}
```

**Why this works:**
- Parent: `relative` + `flex` for content layout
- Background: **First child** with `absolute inset-0` (renders behind)
- Content: Comes after background (natural DOM order puts it on top)
- Avoids z-index complexity

**Note:** While z-index classes exist, natural stacking order is more reliable and simpler.

---

### Issue Type 4: Inline Gradients

**Pattern:** `"GRADIENT on '[Name]' - raw fills data provided for LLM"`

**Cause:** Node has gradient fill - needs inline CSS.

**Resolution:**
Extract gradient from Figma `fills` array and convert to CSS:

```json
// Figma data shows:
{"fills": [{"type": "GRADIENT_LINEAR", "gradientStops": [{"color": "#0ea5e9", "position": 0}, {"color": "#0284c7", "position": 1}]}]}

// After:
{"type": "html", "html": "<div style=\"background: linear-gradient(90deg, #0ea5e9 0%, #0284c7 100%); width: 100%; height: 100%;\"></div>", "styleClasses": "w-[1440px] h-[420px] mb-0", "BFName": "gradient_background"}
```

---

### Enhancement: Semantic Improvements

Apply these even if not flagged as issues:

**Better BFName values:**
- `"Name"` ‚Üí `"customer_name"`
- `"Text"` ‚Üí `"description_text"` or `"heading_title"`
- `"Frame 123"` ‚Üí `"card_container"` or `"hero_section"`

**Semantic HTML tags:**
- Large bold text ‚Üí `<h1>`, `<h2>`, `<h3>`
- Body text ‚Üí `<p>`
- Quotes ‚Üí `<blockquote>`
- Lists ‚Üí `<ul>` + `<li>`

**Accessibility:**
- Images ‚Üí add `alt` attributes
- Icon buttons ‚Üí add `aria-label`
- Maintain heading hierarchy

**Button detection and flattening:**

When you see nested groups that are clearly buttons, **flatten them to `type: "button"`**:

```json
// Before (nested icon button groups from preprocessor):
{"type": "group", "BFName": "icon_button_edit", "fields": [
  {"type": "group", "fields": [
    {"html": "<i class=\"fa-regular fa-edit\"></i>"}
  ]}
]}

// After (flattened to button):
{"type": "button", "icon": "fa-regular fa-edit", "text": "", "actions": [], "buttonClasses": "p-[4px] w-[28px] h-[28px] rounded text-[#0c4a6e]", "styleClasses": "mb-0"}
```

**Extract the icon from nested HTML and move styling to buttonClasses.**

</fix_patterns>

---

<persistence>

## Task Completion

- Work through ALL issues in the `meta.issues` array systematically
- Apply semantic enhancements throughout the schema
- Only stop when:
  - All flagged issues are resolved
  - Semantic improvements are applied
  - Output is valid JSON
- Do NOT stop to ask clarifying questions - use reasonable defaults based on Figma data
- Do NOT explain your changes - return only the final JSON schema

</persistence>

---

<efficiency>

## Optimization

- **Draft schema is your starting point** - do not rebuild from scratch
- **Preserve working conversions** - only modify what needs fixing
- **Batch similar fixes** - handle all image issues together, all layout issues together
- **Validate as you go** - ensure JSON remains valid after each change

## Spacing Best Practices

### üö® CRITICAL: BetterForms Legacy Margin-Bottom Override

**BetterForms has legacy CSS that adds default `margin-bottom` to all elements.**

**The preprocessor adds `mb-0` to all elements by default.** You should:
- ‚úÖ **Preserve `mb-0`** when no spacing needed (most cases)
- ‚úÖ **Change to `mb-[X]`** when specific spacing is required
- ‚úÖ **Use `my-[X]` or `m-[X]`** for vertical/all margins
- ‚ùå **NEVER remove margin classes entirely** - legacy CSS will interfere

```json
// Draft from preprocessor (has mb-0 by default):
{"html": "Quote", "styleClasses": "text-[24px] mb-0"}

// Keep as-is if no special spacing needed:
{"html": "Quote", "styleClasses": "text-[24px] mb-0"}  // ‚úÖ

// OR change if specific spacing needed:
{"html": "Quote", "styleClasses": "text-[24px] mb-4"}  // ‚úÖ

// DO NOT remove margin class:
{"html": "Quote", "styleClasses": "text-[24px]"}  // ‚ùå Legacy CSS interferes!
```

### Prefer Natural Stacking Over Z-Index

**Z-index classes may not work reliably in all BetterForms contexts.**

**Preferred approach:** Use natural DOM stacking order when possible
- Later elements in the `fields` array appear above earlier ones
- For background overlays, make the background the **first child** with `absolute inset-0`

**Only use z-index if natural stacking doesn't work for your specific use case.**

---

### Font Awesome Icons

**If `data-figma-font` contains "Font Awesome"**, the html is an icon ligature - convert to Font Awesome class:

```json
// Before: {"html": "edit", "data-figma-font": "Font Awesome 6 Pro"}
// After:  {"html": "<i class=\"fa-regular fa-edit\"></i>"}
```

Common mappings: "edit" ‚Üí `fa-edit`, "bookmark" ‚Üí `fa-bookmark`, "history" ‚Üí `fa-history`, "thumbtack" ‚Üí `fa-thumbtack`, "minus" ‚Üí `fa-minus`

</efficiency>

---

<validation>

## Output Requirements

**üö® CRITICAL: Return a SINGLE root element (object) starting with `{` and ending with `}`**

**The root element is the top-level container/field from the draft schema. If the draft has multiple top-level fields, wrap them in a group.**

---

### ‚úÖ CORRECT - Button Group Example:

```json
{
  "type": "group",
  "BFName": "button_group",
  "styleClasses": "flex flex-row gap-6",
  "attributes": {
    "formGroup": {
      "data-idbf": "idbf_g_..."
    }
  },
  "fields": [
    {
      "type": "button",
      "BFName": "btn_get_started",
      "text": "Get Started",
      "buttonClasses": "...",
      "attributes": {
        "formElement": {
          "data-idbf": "idbf_e_..."
        }
      }
    },
    {
      "type": "button",
      "BFName": "btn_demo",
      "text": "Request Demo",
      "buttonClasses": "...",
      "attributes": {
        "formElement": {
          "data-idbf": "idbf_e_..."
        }
      }
    }
  ]
}
```

### ‚úÖ CORRECT - Single Text Element:

```json
{
  "type": "html",
  "BFName": "welcome_heading",
  "html": "<h1>Welcome!</h1>",
  "styleClasses": "text-4xl font-bold",
  "attributes": {
    "formElement": {
      "data-idbf": "idbf_e_..."
    }
  }
}
```

### ‚ùå WRONG - Wrapped in Array:

```json
[
  {
    "type": "group",
    "fields": [...]
  }
]
```

### ‚ùå WRONG - Extra Wrapper Object:

```json
{
  "schema": { "fields": [...] }
}
```

### ‚ùå WRONG - Attributes WITHOUT Wrapper Objects:

```json
{
  "type": "group",
  "BFName": "my_group",
  "attributes": { "data-idbf": "idbf_g_123" },
  "fields": [...]
}
```

**Correct version (MUST wrap in formGroup/formElement):**
```json
{
  "type": "group",
  "BFName": "my_group",
  "attributes": {
    "formGroup": {
      "data-idbf": "idbf_g_123"
    }
  },
  "fields": [...]
}
```

---

### Requirements Checklist:

1. ‚úì **Start with `{`** and **end with `}`** (single JSON object)
2. ‚úì Root element has `type` property (group, html, button, etc.)
3. ‚úì Every element has `styleClasses` property (even if empty string)
4. ‚úì **Preserve or modify margin classes** (draft has `mb-0` by default - keep or change to `mb-[X]`/`my-[X]` as needed)
5. ‚úì Every element has `attributes` wrapped in `formGroup` (for groups) or `formElement` (for elements)
6. ‚úì Every element has `BFName` property
7. ‚úì All issues from `meta.issues` are addressed
8. ‚úì Structure preserved from draft schema (same hierarchy)
9. ‚úì Semantic HTML used where appropriate
10. ‚úì Prefer natural stacking order over z-index classes when possible
11. ‚úì NO explanatory text, NO markdown code fences, NO comments outside JSON

</validation>

---

## Execute Task

**Figma Data (for context):**
{{$figmaData}}

**Draft Schema (your starting point):**
{{$draftSchema}}

**Issues to Address:**
{{$issues}}

---

**üö® CRITICAL OUTPUT FORMAT üö®**

**YOUR ENTIRE RESPONSE MUST BE A SINGLE, COMPLETE BETTERFORMS ELEMENT.**

That means the root object MUST have ALL of these properties:
1. ‚úÖ `"type"` - One of: group, html, button, input, textArea
2. ‚úÖ `"BFName"` - descriptive name in lowercase_with_underscores
3. ‚úÖ `"styleClasses"` - Tailwind classes (can be empty string)
4. ‚úÖ `"attributes"` - With formGroup or formElement wrapper containing data-idbf
5. ‚úÖ IF type is "group": Must have `"fields"` array
6. ‚úÖ IF type is "html": Must have `"html"` property
7. ‚úÖ IF type is "button": Must have `"text"` and `"buttonClasses"` properties

**‚ùå DO NOT return an incomplete object with only `attributes` and `fields`**
**‚ùå DO NOT wrap the output in any additional objects or arrays**

**BEGIN YOUR RESPONSE WITH `{` AND END WITH `}`**

Process the draft schema above, fix all issues, add semantic improvements, and return the final single root element as a complete JSON object.
