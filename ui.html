<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>FM BetterForms Figma Bridge</title>
  <style>
    * { box-sizing: border-box; }
    body { margin: 0; padding: 0; font: 12px/1.4 -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif; color: #111827; }
    .header { background: #ffffff; border-bottom: 1px solid #e5e7eb; padding: 8px 12px; display: flex; align-items: center; gap: 8px; }
    .header .spacer { flex: 1; }
    .header img { height: 16px; display: block; }
    .section { padding: 0; border-bottom: none; }
    .row { display: flex; gap: 8px; align-items: center; }
    .row.inline { gap: 8px; }
    .row > label { width: 84px; color: #374151; }
    input[type="text"], input[type="password"] { flex: 1; padding: 6px 8px; border: 1px solid #d1d5db; border-radius: 4px; }
    input[type="text"]::placeholder, input[type="password"]::placeholder { color: #9ca3af; }
    #elementName { flex: none !important; }
    
    .actions { display: flex; gap: 8px; }
    button { appearance: none; border: 1px solid #d1d5db; background: #f9fafb; padding: 6px 10px; border-radius: 4px; cursor: pointer; }
    button.primary { background: #0369a1; color: white; border-color: #0369a1; }
    button:disabled { opacity: 0.5; cursor: not-allowed; }
    button.wide { width: 100%; }
    .small { font-size: 11px; color: #6b7280; }
    .feedback { margin-top: 8px; padding: 8px; border-radius: 4px; font-size: 12px; }
    .feedback.success { background: #d1fae5; color: #065f46; border: 1px solid #a7f3d0; }
    .feedback.error { background: #fee2e2; color: #991b1b; border: 1px solid #fecaca; }

    /* Tabs */
    .tabs { display: flex; border-bottom: 1px solid #e5e7eb; margin: 0; padding: 4px 12px 0; gap: 4px; }
    .tab { padding: 8px 16px; cursor: pointer; border: none; background: transparent; font-weight: 500; color: #6b7280; font-size: 13px; border-radius: 6px 6px 0 0; margin-bottom: -1px; }
    .tab.active { background: #f3f4f6; color: #111827; }
    .tabpane { display: none; }
    .tabpane.active { display: flex; flex-direction: column; height: 435px; }
    .tabpane-content { flex: 1; display: flex; flex-direction: column; overflow: hidden; }
    .tabpane-footer { flex-shrink: 0; }
    .empty-state { display: flex; align-items: center; justify-content: center; min-height: 200px; color: #9ca3af; font-size: 13px; }
    #preview { border-radius: 4px; padding: 16px; width: 100%; height: 100%; display: flex; align-items: center; justify-content: center; background: #F5F5F5; }
    
    /* JSON tab with copy button */
    .json-container { position: relative; width: 100%; height: 100%; }
    .copy-btn { position: absolute; top: 8px; right: 8px; padding: 4px 8px; font-size: 11px; z-index: 10; }
    .copy-btn.copied { background: #10b981; color: white; border-color: #10b981; }
    
    /* Animated checkmark */
    .copy-check {
      position: absolute;
      top: 8px;
      right: 8px;
      width: 32px;
      height: 32px;
      background: #10b981;
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      color: white;
      font-size: 18px;
      font-weight: bold;
      pointer-events: none;
      animation: checkPop 0.6s ease-out forwards;
      z-index: 20;
    }
    
    @keyframes checkPop {
      0% {
        transform: scale(0.5);
        opacity: 0;
      }
      50% {
        transform: scale(1.2);
        opacity: 1;
      }
      70% {
        transform: scale(1);
        opacity: 1;
      }
      100% {
        transform: scale(1) translateY(-20px);
        opacity: 0;
      }
    }
    
    /* Modal */
    .modal-overlay {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0, 0, 0, 0.5);
      display: none;
      align-items: center;
      justify-content: center;
      z-index: 1000;
    }
    .modal-overlay.active {
      display: flex;
    }
    .modal {
      background: white;
      border-radius: 8px;
      padding: 20px;
      max-width: 400px;
      width: 90%;
      box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
    }
    .modal-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 16px;
    }
    .modal-title {
      font-size: 16px;
      font-weight: 600;
    }
    .modal-close {
      background: none;
      border: none;
      font-size: 20px;
      cursor: pointer;
      padding: 0;
      color: #6b7280;
    }
    .modal-body {
      margin-bottom: 16px;
    }
    .modal-setting {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 12px 0;
      border-bottom: 1px solid #e5e7eb;
    }
    .modal-setting:last-child {
      border-bottom: none;
    }
    .modal-setting-label {
      flex: 1;
    }
    .modal-setting-label strong {
      display: block;
      font-size: 13px;
      margin-bottom: 4px;
    }
    .modal-setting-label .small {
      display: block;
      color: #6b7280;
      font-size: 11px;
    }
    
    /* Toggle Switch */
    .toggle-switch {
      position: relative;
      width: 44px;
      height: 24px;
      flex-shrink: 0;
    }
    .toggle-switch input {
      opacity: 0;
      width: 0;
      height: 0;
    }
    .toggle-slider {
      position: absolute;
      cursor: pointer;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background-color: #d1d5db;
      transition: 0.3s;
      border-radius: 24px;
    }
    .toggle-slider:before {
      position: absolute;
      content: "";
      height: 18px;
      width: 18px;
      left: 3px;
      bottom: 3px;
      background-color: white;
      transition: 0.3s;
      border-radius: 50%;
    }
    .toggle-switch input:checked + .toggle-slider {
      background-color: #0369a1;
    }
    .toggle-switch input:checked + .toggle-slider:before {
      transform: translateX(20px);
    }
    
    /* Ellipsis button */
    .ellipsis-btn {
      background: transparent;
      border: none;
      cursor: pointer;
      padding: 4px 8px;
      font-size: 18px;
      color: #6b7280;
      line-height: 1;
    }
    .ellipsis-btn:hover {
      color: #111827;
    }
    
    /* Loading Spinner */
    .loading-spinner {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      gap: 12px;
      color: #9ca3af;
      font-size: 13px;
      width: 100%;
      height: 100%;
      min-height: 200px;
    }
    .spinner {
      width: 32px;
      height: 32px;
      border: 3px solid #e5e7eb;
      border-top-color: #0369a1;
      border-radius: 50%;
      animation: spin 0.8s linear infinite;
    }
    @keyframes spin {
      to { transform: rotate(360deg); }
    }
  </style>
  <script>
    const VERSION = '0.8.7'
    const BUILD = 107
    let state = { 
      apiKey: '', 
      activeTab: 'preview', 
      selectionData: null, 
      tokens: null, 
      sending: false, 
      sendAs: 'element', 
      elementName: '',
      loadingPreview: false, // Track if we're currently loading a preview
      preprocessing: {
        enabled: true,
        mode: 'auto'
      },
      stripAllSvg: false, // Strip all SVG exports, not just >30KB
      outerElementFullWidth: true, // Outer element uses 100% width (default ON)
      stripRedundantChildFills: true, // Strip child backgrounds that match parent (default ON)
      applyOverflowHidden: true, // Add overflow-hidden to rounded containers (default ON)
      lastTestCase: null // Stores: { source, preprocessorResult, prompt, llmOutput, meta }
    }

    onmessage = (event) => {
      const msg = event.data.pluginMessage
      if (!msg) return
      if (msg.type === 'init') {
        state.apiKey = msg.apiKey || ''
        const inp = document.getElementById('apiKey')
        if (inp) inp.value = state.apiKey
        renderHeader()
        renderAccountSection()
        // Load preprocessing settings
        loadPreprocessingSettings(msg.preprocessEnabled, msg.preprocessMode)
        // Load export settings
        loadExportSettings(msg.stripAllSvg, msg.outerElementFullWidth, msg.stripRedundantChildFills, msg.applyOverflowHidden)
        // Switch to account tab if no API key
        if (!state.apiKey) {
          setActiveTab('account')
        }
      }
      if (msg.type === 'selection.loading') {
        // Show loading spinner when backend starts exporting
        state.loadingPreview = true
        const previewEl = document.getElementById('preview')
        if (previewEl) {
          previewEl.innerHTML = '<div class="loading-spinner"><div class="spinner"></div><div>Generating preview...</div></div>'
        }
        return
      }
      if (msg.type === 'selection.full') {
        state.loadingPreview = false
        state.sendAs = inferSendType(msg.selection)
        state.selectionData = msg.selection
        state.tokens = msg.tokens || null
        renderSelection(msg.selection)
      }
    }

    // Handshake so worker can resend stored key on reload
    window.addEventListener('load', () => {
      parent.postMessage({ pluginMessage: { type: 'ui-ready' } }, '*')
      const vf = document.getElementById('versionFooter')
      if (vf) vf.textContent = `v${VERSION}`
    })

    function save() {
      const apiKey = document.getElementById('apiKey').value.trim()
      parent.postMessage({ pluginMessage: { type: 'save-settings', apiKey } }, '*')
      state.apiKey = apiKey
      renderHeader()
      renderAccountSection()
    }

    function logout() {
      parent.postMessage({ pluginMessage: { type: 'logout' } }, '*')
      state.apiKey = ''
      const inp = document.getElementById('apiKey')
      if (inp) inp.value = ''
      renderHeader()
      renderAccountSection()
    }

    function renderHeader() {
      const btn = document.getElementById('logoutBtn')
      if (!btn) return
      btn.style.display = state.apiKey ? 'inline-flex' : 'none'
    }

    function renderAccountSection() {
      const unsaved = document.getElementById('accountUnsaved')
      const saved = document.getElementById('accountSaved')
      if (unsaved) unsaved.style.display = state.apiKey ? 'none' : 'block'
      if (saved) saved.style.display = state.apiKey ? 'block' : 'none'
    }

    function updateElementName(value) {
      state.elementName = value
    }

    // Preprocessing is now always enabled in 'auto' mode
    function loadPreprocessingSettings(enabled, mode) {
      // Always enable preprocessing in auto mode
      state.preprocessing.enabled = true
      state.preprocessing.mode = 'auto'
    }

    function loadExportSettings(stripAllSvg, outerElementFullWidth, stripRedundantChildFills, applyOverflowHidden) {
      state.stripAllSvg = stripAllSvg === true
      state.outerElementFullWidth = outerElementFullWidth !== false // Default to true
      state.stripRedundantChildFills = stripRedundantChildFills !== false // Default to true
      state.applyOverflowHidden = applyOverflowHidden !== false // Default to true
      
      const stripSvgCheckbox = document.getElementById('stripAllSvgToggle')
      if (stripSvgCheckbox) stripSvgCheckbox.checked = state.stripAllSvg
      
      const fullWidthCheckbox = document.getElementById('outerElementFullWidthToggle')
      if (fullWidthCheckbox) fullWidthCheckbox.checked = state.outerElementFullWidth
      
      const stripBgCheckbox = document.getElementById('stripRedundantChildFillsToggle')
      if (stripBgCheckbox) stripBgCheckbox.checked = state.stripRedundantChildFills
      
      const overflowCheckbox = document.getElementById('applyOverflowHiddenToggle')
      if (overflowCheckbox) overflowCheckbox.checked = state.applyOverflowHidden
    }

    function openExportModal() {
      const modal = document.getElementById('exportModal')
      if (modal) modal.classList.add('active')
    }

    function closeExportModal() {
      const modal = document.getElementById('exportModal')
      if (modal) modal.classList.remove('active')
    }

    function toggleStripAllSvg() {
      const checkbox = document.getElementById('stripAllSvgToggle')
      state.stripAllSvg = checkbox.checked
      saveExportSettings()
    }

    function toggleOuterElementFullWidth() {
      const checkbox = document.getElementById('outerElementFullWidthToggle')
      state.outerElementFullWidth = checkbox.checked
      saveExportSettings()
    }

    function toggleStripRedundantChildFills() {
      const checkbox = document.getElementById('stripRedundantChildFillsToggle')
      state.stripRedundantChildFills = checkbox.checked
      saveExportSettings()
    }

    function toggleApplyOverflowHidden() {
      const checkbox = document.getElementById('applyOverflowHiddenToggle')
      state.applyOverflowHidden = checkbox.checked
      saveExportSettings()
    }

    function saveExportSettings() {
      parent.postMessage({ 
        pluginMessage: { 
          type: 'save-export-settings', 
          stripAllSvg: state.stripAllSvg,
          outerElementFullWidth: state.outerElementFullWidth,
          stripRedundantChildFills: state.stripRedundantChildFills,
          applyOverflowHidden: state.applyOverflowHidden
        } 
      }, '*')
    }


    // Infer an export type from the current selection
    function inferSendType(selection) {
      if (!Array.isArray(selection) || selection.length === 0) return 'element'
      if (selection.length > 1) return 'element'
      const n = selection[0] || {}
      const t = n.type
      if (t === 'COMPONENT' || t === 'INSTANCE' || t === 'COMPONENT_SET') return 'component'
      if (n.isTopLevel && (t === 'FRAME' || t === 'GROUP')) return 'page'
      return 'element'
    }

    // ========== JS PREPROCESSOR ==========
    
    /**
     * Preprocess Figma selection data to generate draft BetterForms schema
     * @param {Array} selectionData - Figma node tree
     * @param {Object} tokens - Design tokens (all + used)
     * @returns {Object} { success, normalizedData, draftSchema, meta, error }
     */
    async function preprocessSelection(selectionData, tokens, elementName = '') {
      const startTime = Date.now()
      
      try {
        // Flatten all nodes for complexity analysis
        const allNodes = flattenNodes(selectionData)
        
        // Calculate complexity metrics
        const metrics = calculateComplexityMetrics(allNodes)
        const complexityScore = calculateComplexityScore(metrics)
        
        // Count SVGs before we potentially strip them
        const svgInfo = countSvgs(selectionData)
        
        // Always generate draft schema - let the caller decide whether to use it
        const issues = []
        const draftSchema = generateDraftSchema(selectionData, tokens, issues, elementName)
        
        // Recommend a route based on complexity (for 'auto' mode)
        const recommendedRoute = complexityScore <= 40 ? 'pre' : 'raw'
        
        // Normalize data
        const normalizedData = normalizeData(selectionData)
        
        const processingTime = Date.now() - startTime
        
        // Estimate token count for FULL payload (Figma JSON + draft schema)
        // This is what actually gets sent to the LLM
        const figmaTokens = estimateTokenCount(normalizedData)
        const schemaTokens = draftSchema ? estimateTokenCount(draftSchema) : 0
        const estimatedTokens = figmaTokens + schemaTokens
        
        // Token warning logic
        // Warn at 75K data tokens (prompt ~35K + data ~75K + output ~25K ≈ 135K, safe from 150K cap)
        let tokenWarning = null
        if (estimatedTokens > 75000) {
          tokenWarning = {
            level: 'high',
            estimatedTokens,
            figmaTokens,
            schemaTokens,
            message: 'Selection is very large and may exceed context limits',
            suggestions: []
          }
          
          // Suggest SVG stripping if SVGs are contributing significantly
          if (svgInfo.count > 0 && svgInfo.totalSize > 10000) {
            const svgTokens = Math.round(svgInfo.totalSize / 3.5)
            tokenWarning.suggestions.push({
              action: 'strip_svg',
              description: `${svgInfo.count} SVG(s) detected (~${svgTokens.toLocaleString()} tokens). Enable "Strip All SVG Exports" in settings to reduce size.`
            })
          }
          
          tokenWarning.suggestions.push({
            action: 'split',
            description: 'Consider exporting this design in smaller parts for best results.'
          })
        }
        
        return {
          success: true,
          normalizedData,
          draftSchema,
          meta: {
            version: '0.1.0',
            complexityScore,
            metrics,
            issues,
            recommendedRoute,
            processingTime,
            estimatedTokens,
            svgInfo,
            tokenWarning
          }
        }
      } catch (error) {
        console.error('Preprocessing failed:', error)
        return {
          success: false,
          error: error.message,
          normalizedData: selectionData,
          draftSchema: null,
          meta: null
        }
      }
    }

    function flattenNodes(nodes, result = []) {
      if (!Array.isArray(nodes)) return result
      
      for (const node of nodes) {
        if (!node) continue
        result.push(node)
        if (node.children && Array.isArray(node.children)) {
          flattenNodes(node.children, result)
        }
      }
      
      return result
    }

    function calculateComplexityMetrics(allNodes) {
      const metrics = {
        elementCount: allNodes.length,
        absoluteCount: 0,
        gradientsCount: 0,
        vectorsCount: 0,
        multiEffectsCount: 0,
        instancesCount: 0
      }
      
      for (const node of allNodes) {
        // Check for absolute positioning
        if (node.constraints && node.constraints.horizontal === 'ABSOLUTE') {
          metrics.absoluteCount++
        }
        
        // Check for gradients
        if (node.fills && Array.isArray(node.fills)) {
          for (const fill of node.fills) {
            if (fill.type && fill.type.includes('GRADIENT')) {
              metrics.gradientsCount++
              break
            }
          }
        }
        
        // Check for vectors
        if (node.type === 'VECTOR') {
          metrics.vectorsCount++
        }
        
        // Check for multiple effects (shadows, blurs)
        if (node.effects && Array.isArray(node.effects) && node.effects.length > 2) {
          metrics.multiEffectsCount++
        }
        
        // Check for instances
        if (node.type === 'INSTANCE') {
          metrics.instancesCount++
        }
      }
      
      return metrics
    }

    function calculateComplexityScore(metrics) {
      const score = 
        metrics.elementCount * 0.5 +
        metrics.absoluteCount * 2 +
        metrics.gradientsCount * 3 +
        metrics.vectorsCount * 1.5 +
        metrics.multiEffectsCount * 2 +
        metrics.instancesCount * 1
      
      return Math.min(100, Math.round(score))
    }
    
    /**
     * Estimate token count for data
     * Rough estimate: 1 token ≈ 3.5 characters for JSON
     */
    function estimateTokenCount(data) {
      const jsonStr = JSON.stringify(data)
      return Math.round(jsonStr.length / 3.5)
    }
    
    /**
     * Count SVGs in node tree
     */
    function countSvgs(nodes) {
      let count = 0
      let totalSize = 0
      
      function walk(node) {
        if (!node) return
        if (node.svg && typeof node.svg === 'string') {
          count++
          totalSize += node.svg.length
        }
        if (Array.isArray(node.children)) {
          node.children.forEach(walk)
        }
      }
      
      if (Array.isArray(nodes)) {
        nodes.forEach(walk)
      }
      
      return { count, totalSize }
    }

    function normalizeData(data) {
      // For now, just return a deep clone
      // Future: normalize colors, round numbers, etc.
      return JSON.parse(JSON.stringify(data))
    }

    function generateDraftSchema(selectionData, tokens, issues, elementName = '') {
      if (!selectionData || selectionData.length === 0) return null
      
      const rootNode = selectionData[0]
      
      // Process the root node (pass true for isRootNode)
      const rootFields = processNodeToFields(rootNode, tokens, issues, true)
      
      // If elementName override is provided, set it on the root element
      if (elementName && rootFields.length > 0) {
        // Convert to lowercase with underscores
        const bfName = elementName.toLowerCase().replace(/[^a-z0-9]+/g, '_').replace(/^_+|_+$/g, '')
        rootFields[0].BFName = bfName
      }
      
      const schema = rootFields[0] || null
      
      // Strip redundant child backgrounds if enabled
      if (state.stripRedundantChildFills && schema) {
        const strippedCount = stripRedundantBackgrounds(schema, null)
        if (strippedCount > 0) {
          issues.push(`Stripped ${strippedCount} redundant background(s) matching parent`)
        }
      }
      
      // Apply overflow-hidden to rounded containers if enabled
      if (state.applyOverflowHidden && schema) {
        const appliedCount = applyOverflowHiddenToRounded(schema)
        if (appliedCount > 0) {
          issues.push(`Applied overflow-hidden to ${appliedCount} rounded container(s)`)
        }
      }
      
      // Return just the single root element (always one selection)
      return schema
    }
    
    // ========== STRIP REDUNDANT BACKGROUNDS ==========
    
    /**
     * Extract background color from styleClasses string
     * Returns null if no background found
     */
    function extractBackground(styleClasses) {
      if (!styleClasses || typeof styleClasses !== 'string') return null
      
      // Match bg- classes: bg-white, bg-red-600, bg-[#fff], bg-[var(--color)]
      const bgMatch = styleClasses.match(/bg-(\[[^\]]+\]|[\w-]+(?:\/\d+)?)/);
      if (!bgMatch) return null
      
      return bgMatch[0] // Return full match (e.g., "bg-white" or "bg-[#fff]")
    }
    
    /**
     * Normalize hex colors for comparison
     * #fff -> #ffffff, #FFF -> #ffffff
     */
    function normalizeHexColor(hexStr) {
      if (!hexStr) return null
      
      // Extract hex value from bg-[#...] format
      const hexMatch = hexStr.match(/#([0-9a-fA-F]+)/);
      if (!hexMatch) return hexStr // Not a hex color, return as-is
      
      let hex = hexMatch[1].toLowerCase()
      
      // Expand short hex: fff -> ffffff
      if (hex.length === 3) {
        hex = hex[0] + hex[0] + hex[1] + hex[1] + hex[2] + hex[2]
      }
      
      return `bg-[#${hex}]`
    }
    
    /**
     * Check if two background colors match
     * Handles: Tailwind classes, hex colors (with normalization), tokens, opacity
     */
    function backgroundsMatch(bg1, bg2) {
      if (!bg1 || !bg2) return false
      if (bg1 === bg2) return true // Exact match
      
      // Normalize hex colors for comparison
      const norm1 = normalizeHexColor(bg1)
      const norm2 = normalizeHexColor(bg2)
      
      return norm1 === norm2
    }
    
    /**
     * Remove background from styleClasses string
     */
    function removeBackground(styleClasses, bgToRemove) {
      if (!styleClasses || !bgToRemove) return styleClasses
      
      // Remove the background class and clean up extra spaces
      return styleClasses
        .replace(bgToRemove, '')
        .replace(/\s+/g, ' ')
        .trim()
    }
    
    /**
     * Recursively strip redundant backgrounds from schema tree
     * Returns count of backgrounds stripped
     */
    function stripRedundantBackgrounds(field, parentBg) {
      if (!field) return 0
      
      let count = 0
      
      // Extract background from current field
      const currentBg = extractBackground(field.styleClasses)
      
      // If this field's background matches parent's, remove it
      if (parentBg && currentBg && backgroundsMatch(currentBg, parentBg)) {
        field.styleClasses = removeBackground(field.styleClasses, currentBg)
        count++
      }
      
      // Recurse into children with THIS field's background (or parent's if none)
      if (field.fields && Array.isArray(field.fields)) {
        const bgForChildren = currentBg || parentBg
        for (const child of field.fields) {
          count += stripRedundantBackgrounds(child, bgForChildren)
        }
      }
      
      return count
    }
    
    // ========== APPLY OVERFLOW HIDDEN ==========
    
    /**
     * Check if element has rounded corners
     */
    function hasRoundedCorners(styleClasses) {
      if (!styleClasses || typeof styleClasses !== 'string') return false
      
      // Match: rounded, rounded-md, rounded-lg, rounded-xl, rounded-2xl, rounded-full, rounded-[Npx]
      return /rounded(?:-\w+|-\[\d+px\])?/.test(styleClasses)
    }
    
    /**
     * Check if element already has overflow class
     */
    function hasOverflowClass(styleClasses) {
      if (!styleClasses || typeof styleClasses !== 'string') return false
      return /overflow-(?:hidden|auto|scroll|visible|clip)/.test(styleClasses)
    }
    
    /**
     * Recursively apply overflow-hidden to rounded containers with children
     * Returns count of elements modified
     */
    function applyOverflowHiddenToRounded(field) {
      if (!field) return 0
      
      let count = 0
      
      // Check if this is a group/container with rounded corners and children
      const isGroup = field.type === 'group' || field.fields
      const hasChildren = field.fields && Array.isArray(field.fields) && field.fields.length > 0
      const isRounded = hasRoundedCorners(field.styleClasses)
      const hasOverflow = hasOverflowClass(field.styleClasses)
      
      // Add overflow-hidden if:
      // - It's a container with children
      // - Has rounded corners
      // - Doesn't already have an overflow class
      if (isGroup && hasChildren && isRounded && !hasOverflow) {
        field.styleClasses = (field.styleClasses + ' overflow-hidden').trim()
        count++
      }
      
      // Recurse into children
      if (field.fields && Array.isArray(field.fields)) {
        for (const child of field.fields) {
          count += applyOverflowHiddenToRounded(child)
        }
      }
      
      return count
    }

    function processNodeToFields(node, tokens, issues, isRootNode = false) {
      if (!node) return []
      
      const fields = []
      
      // Process based on node type
      if (node.type === 'TEXT') {
        fields.push(processTextNode(node, tokens, issues))
      } else if (node.type === 'FRAME' || node.type === 'GROUP' || node.type === 'INSTANCE') {
        fields.push(processContainerNode(node, tokens, issues, isRootNode))
      } else if (node.type === 'RECTANGLE' || node.type === 'ELLIPSE' || node.type === 'VECTOR') {
        fields.push(processShapeNode(node, tokens, issues))
      }
      
      return fields
    }

    function processTextNode(node, tokens, issues) {
      const field = {
        type: 'html',
        html: node.characters || '',
        styleClasses: ['mb-0'],  // Default margin override (LLM can change)
        attributes: {
          formElement: {
            'data-idbf': node.id
          }
        }
      }
      
      // Check for Font Awesome icons (Font Awesome 6 Pro, Font Awesome 7, etc.)
      let isFontAwesomeIcon = false
      let fontAwesomeClass = ''
      if (node.textStyle && node.textStyle.fontName && node.textStyle.fontName.family) {
        const fontFamily = node.textStyle.fontName.family
        const fontStyle = node.textStyle.fontName.style || ''
        
        // Check if it's Font Awesome (6, 7, or any version)
        if (fontFamily.toLowerCase().includes('font awesome')) {
          isFontAwesomeIcon = true
          
          // Determine the Font Awesome style class
          const styleLower = fontStyle.toLowerCase()
          if (styleLower.includes('solid')) {
            fontAwesomeClass = 'fa-solid'
          } else if (styleLower.includes('regular')) {
            fontAwesomeClass = 'fa-regular'
          } else if (styleLower.includes('light')) {
            fontAwesomeClass = 'fa-light'
          } else if (styleLower.includes('thin')) {
            fontAwesomeClass = 'fa-thin'
          } else if (styleLower.includes('duotone')) {
            fontAwesomeClass = 'fa-duotone'
          } else if (styleLower.includes('brands')) {
            fontAwesomeClass = 'fa-brands'
          } else {
            // Default to solid if no style detected
            fontAwesomeClass = 'fa-solid'
          }
          
          // Convert to Font Awesome icon tag
          const iconName = node.characters || 'question'
          field.html = `<i class="${fontAwesomeClass} fa-${iconName}"></i>`
        }
      }
      
      // Add size classes
      if (node.size) {
        field.styleClasses.push(`w-[${Math.round(node.size.w)}px]`)
        field.styleClasses.push(`h-[${Math.round(node.size.h)}px]`)
      }
      
      // Add text styles
      if (node.textStyle) {
        // Font size
        if (node.textStyle.fontSize && typeof node.textStyle.fontSize === 'number') {
          field.styleClasses.push(`text-[${Math.round(node.textStyle.fontSize)}px]`)
        }
        
        // Font weight - Figma stores as string in fontName.style (skip for Font Awesome)
        if (!isFontAwesomeIcon && node.textStyle.fontName && node.textStyle.fontName.style) {
          const style = node.textStyle.fontName.style.toLowerCase()
          if (style.includes('extra bold') || style.includes('extrabold') || style.includes('black')) {
            field.styleClasses.push('font-extrabold')
          } else if (style.includes('bold')) {
            field.styleClasses.push('font-bold')
          } else if (style.includes('semibold') || style.includes('semi bold')) {
            field.styleClasses.push('font-semibold')
          } else if (style.includes('medium')) {
            field.styleClasses.push('font-medium')
          }
          // Regular/Light/Thin - no class needed (default)
        }
        
        // Store font family in a custom data attribute for LLM to use (skip for Font Awesome)
        if (!isFontAwesomeIcon && node.textStyle.fontName && node.textStyle.fontName.family) {
          field.attributes.formElement['data-figma-font'] = node.textStyle.fontName.family
        }
      }
      
      // Add TEXT COLOR (not background)
      const textColor = getTextColor(node, tokens)
      if (textColor) field.styleClasses.push(textColor)
      
      field.styleClasses = field.styleClasses.join(' ')
      
      return field
    }

    function processContainerNode(node, tokens, issues, isRootNode = false) {
      // Flag components with variants for LLM to handle state styling
      if ((node.type === 'INSTANCE' || node.type === 'COMPONENT') && node.availableVariants && node.availableVariants.length > 1) {
        const stateProps = node.componentProperties || {}
        const hasStateVariant = Object.keys(stateProps).some(prop => 
          prop.toLowerCase().includes('state') || 
          prop.toLowerCase().includes('hover') || 
          prop.toLowerCase().includes('active')
        )
        if (hasStateVariant || node.availableVariants.length > 1) {
          issues.push(`Component "${node.name}" has ${node.availableVariants.length} variants - LLM should convert to hover/active/disabled states`)
        }
      }
      
      // Check if this GROUP has SVG export (e.g., icon groups like "ic_star")
      // BUT: Only use SVG if children are simple (vectors, not frames/components)
      if (node.type === 'GROUP' && node.svg) {
        // Check if children are complex (FRAMEs, COMPONENTS, etc.)
        const hasComplexChildren = node.children && node.children.some(child => 
          child.type === 'FRAME' || 
          child.type === 'COMPONENT' || 
          child.type === 'INSTANCE' ||
          child.type === 'TEXT'
        )
        
        // If children are complex, process as container (don't use SVG)
        if (hasComplexChildren) {
          issues.push(`GROUP "${node.name}" has complex children - processing as container instead of SVG`)
          // Fall through to normal container processing
        } else {
          // Simple children (vectors, etc.) - export as SVG icon
          const field = {
            type: 'html',  // SVG uses type: "html"
            html: node.svg,
            styleClasses: ['mb-0']  // Default margin override (LLM can change)
          }
          
          // Add size classes if available
          if (node.size) {
            field.styleClasses.push(`w-[${Math.round(node.size.w)}px]`)
            field.styleClasses.push(`h-[${Math.round(node.size.h)}px]`)
          }
          
          // Add attributes in correct BetterForms format
          field.attributes = {
            formElement: {
              'data-idbf': node.id
            }
          }
          
          field.styleClasses = field.styleClasses.join(' ')
          return field
        }
      }
      
      const field = {
        type: 'group',
        label: node.name || 'Container',
        styleClasses: ['mb-0'],  // Default margin override (LLM can change)
        fields: []  // FIX: Direct fields array, not wrapped in schema
      }
      
      // Add data-idbf attribute in correct BetterForms format
      field.attributes = {
        formGroup: {
          'data-idbf': node.id
        }
      }
      
      // Process autolayout - FIX #4
      if (node.autolayout && node.autolayout.direction) {
        const direction = node.autolayout.direction
        
        // Only add flex classes if has actual autolayout direction
        if (direction === 'HORIZONTAL') {
          field.styleClasses.push('flex', 'flex-row')
          
          // Add gap (Figma stores as itemSpacing)
          const gap = node.autolayout.itemSpacing || node.autolayout.gap
          if (gap) {
            field.styleClasses.push(`gap-[${Math.round(gap)}px]`)
          }
          
          // Add alignment
          if (node.autolayout.align && node.autolayout.align.counter) {
            const counterAlign = node.autolayout.align.counter
            if (counterAlign === 'CENTER') field.styleClasses.push('items-center')
            else if (counterAlign === 'MAX') field.styleClasses.push('items-end')
            // MIN is default (items-start)
          }
        } else if (direction === 'VERTICAL') {
          field.styleClasses.push('flex', 'flex-col')
          
          // Add gap (Figma stores as itemSpacing)
          const gap = node.autolayout.itemSpacing || node.autolayout.gap
          if (gap) {
            field.styleClasses.push(`gap-[${Math.round(gap)}px]`)
          }
          
          // Add alignment
          if (node.autolayout.align && node.autolayout.align.counter) {
            const counterAlign = node.autolayout.align.counter
            if (counterAlign === 'CENTER') field.styleClasses.push('items-center')
            else if (counterAlign === 'MAX') field.styleClasses.push('items-end')
            // MIN is default (items-start)
          }
        } else if (direction === 'NONE') {
          // No autolayout - note for LLM
          issues.push(`No autolayout on "${node.name}" - LLM should determine positioning strategy`)
        }
        
        // Add padding (regardless of direction)
        if (node.autolayout.padding) {
          const p = node.autolayout.padding
          // Only add padding if it's not all zeros
          if (p.t !== 0 || p.r !== 0 || p.b !== 0 || p.l !== 0) {
            if (p.t === p.r && p.r === p.b && p.b === p.l) {
              field.styleClasses.push(`p-[${Math.round(p.t)}px]`)
            } else {
              if (p.t !== 0) field.styleClasses.push(`pt-[${Math.round(p.t)}px]`)
              if (p.r !== 0) field.styleClasses.push(`pr-[${Math.round(p.r)}px]`)
              if (p.b !== 0) field.styleClasses.push(`pb-[${Math.round(p.b)}px]`)
              if (p.l !== 0) field.styleClasses.push(`pl-[${Math.round(p.l)}px]`)
            }
          }
        }
      }
      
      // Add size - check for FILL sizing mode to use flex-1
      if (node.size) {
        // Check if this is the root node and outerElementFullWidth is enabled
        if (isRootNode && state.outerElementFullWidth) {
          // Use 100% width for root element so BetterForms can control sizing
          field.styleClasses.push('w-full')
          field.styleClasses.push(`h-[${Math.round(node.size.h)}px]`)
        } else if (node.layoutSizingHorizontal === 'FILL' || node.layoutGrow === 1) {
          // Check if width should be flexible (FILL mode)
          field.styleClasses.push('flex-1')
          // Only add height, not width
          field.styleClasses.push(`h-[${Math.round(node.size.h)}px]`)
        } else {
          // Fixed size
          field.styleClasses.push(`w-[${Math.round(node.size.w)}px]`)
          field.styleClasses.push(`h-[${Math.round(node.size.h)}px]`)
        }
      }
      
      // Add background
      const bgClass = getBackgroundClass(node, tokens)
      if (bgClass) field.styleClasses.push(bgClass)
      
      // Add node-level opacity if not 1
      if (typeof node.opacity === 'number' && node.opacity !== 1) {
        const opacityPercent = Math.round(node.opacity * 100)
        field.styleClasses.push(`opacity-[${opacityPercent}%]`)
      }
      
      // Add border
      const borderClasses = getBorderClasses(node, tokens, issues)
      if (borderClasses.length > 0) {
        field.styleClasses.push(...borderClasses)
      }
      
      // Add corner radius
      const radiusClass = getCornerRadiusClass(node)
      if (radiusClass) field.styleClasses.push(radiusClass)
      
      // Add effects (drop shadows)
      const effectClasses = getEffectClasses(node, issues)
      if (effectClasses.length > 0) {
        field.styleClasses.push(...effectClasses)
      }
      
      // Check for absolute positioning
      if (node.constraints && node.constraints.horizontal === 'ABSOLUTE') {
        issues.push(`Absolute positioning on "${node.name}" - raw coordinates in absoluteTransform`)
      }
      
      // Process children
      if (node.children && Array.isArray(node.children)) {
        for (const child of node.children) {
          const childFields = processNodeToFields(child, tokens, issues)
          field.fields.push(...childFields)  // FIX: Use direct fields array
        }
      }
      
      field.styleClasses = field.styleClasses.join(' ')
      
      return field
    }

    function processShapeNode(node, tokens, issues) {
      const field = {
        type: 'html',
        html: `<!-- ${node.type}: ${node.name} -->`,
        styleClasses: ['mb-0']  // Default margin override (LLM can change)
      }
      
      // Handle VECTOR nodes with SVG export
      if (node.type === 'VECTOR' && node.svg) {
        // Use exported SVG directly
        field.html = node.svg
        field.type = 'html' // SVG uses type: "html"
        
        // Add size classes to wrapper if needed
        if (node.size) {
          field.styleClasses.push(`w-[${Math.round(node.size.w)}px]`)
          field.styleClasses.push(`h-[${Math.round(node.size.h)}px]`)
        }
        
        // Add attributes in correct BetterForms format
        field.attributes = {
          formElement: {
            'data-idbf': node.id
          }
        }
        
        field.styleClasses = field.styleClasses.join(' ')
        return field
      }
      
      // Check for IMAGE fill - FIX #3
      let hasImageFill = false
      if (node.fills && Array.isArray(node.fills)) {
        for (const fill of node.fills) {
          if (fill.type === 'IMAGE') {
            hasImageFill = true
            issues.push(`IMAGE fill on "${node.name}" - LLM should convert to <img> or background-image`)
            break
          }
          if (fill.type && fill.type.includes('GRADIENT')) {
            issues.push(`GRADIENT on "${node.name}" - raw fills data provided for LLM`)
            break
          }
        }
      }
      
      // Add size
      if (node.size) {
        field.styleClasses.push(`w-[${Math.round(node.size.w)}px]`)
        field.styleClasses.push(`h-[${Math.round(node.size.h)}px]`)
      }
      
      // Add background (only if not IMAGE)
      if (!hasImageFill) {
        const bgClass = getBackgroundClass(node, tokens)
        if (bgClass) field.styleClasses.push(bgClass)
      }
      
      // Add node-level opacity if not 1
      if (typeof node.opacity === 'number' && node.opacity !== 1) {
        const opacityPercent = Math.round(node.opacity * 100)
        field.styleClasses.push(`opacity-[${opacityPercent}%]`)
      }
      
      // Add border
      const borderClasses = getBorderClasses(node, tokens, issues)
      if (borderClasses.length > 0) {
        field.styleClasses.push(...borderClasses)
      }
      
      // Add corner radius
      const radiusClass = getCornerRadiusClass(node)
      if (radiusClass) field.styleClasses.push(radiusClass)
      
      // Add effects (drop shadows)
      const effectClasses = getEffectClasses(node, issues)
      if (effectClasses.length > 0) {
        field.styleClasses.push(...effectClasses)
      }
      
      if (node.type === 'VECTOR' && !node.svg) {
        issues.push(`Vector "${node.name}" - SVG export failed, may need manual conversion`)
      }
      
      // Add attributes in correct BetterForms format
      field.attributes = {
        formElement: {
          'data-idbf': node.id
        }
      }
      
      field.styleClasses = field.styleClasses.join(' ')
      
      return field
    }

    function getTextColor(node, tokens) {
      if (!node.fills || !Array.isArray(node.fills)) return null
      
      // Find first visible solid fill for text color
      for (const fill of node.fills) {
        if (fill.visible === false) continue  // FIX #2: Skip invisible
        if (fill.type !== 'SOLID') continue
        
        const color = fill.color
        if (!color) continue
        
        // Check if color matches a token
        if (tokens && tokens.used) {
          for (const token of tokens.used) {
            if (colorsMatch(color, token.value)) {
              return `text-[var(--${token.name})]`
            }
          }
        }
        
        // Return hex color
        return `text-[${color}]`
      }
      
      return null
    }

    function getBackgroundClass(node, tokens) {
      if (!node.fills || !Array.isArray(node.fills)) return null
      
      // Find first visible solid fill
      for (const fill of node.fills) {
        if (fill.visible === false) continue  // FIX #2: Skip invisible
        if (fill.type !== 'SOLID') continue
        
        const color = fill.color
        if (!color) continue
        
        // Check if color matches a token
        if (tokens && tokens.used) {
          for (const token of tokens.used) {
            if (colorsMatch(color, token.value)) {
              return `bg-[var(--${token.name})]`
            }
          }
        }
        
        // Return hex color
        return `bg-[${color}]`
      }
      
      return null
    }

    function getBorderClasses(node, tokens, issues) {
      const classes = []
      
      if (!node.strokes || !Array.isArray(node.strokes) || node.strokes.length === 0) {
        return classes
      }
      
      // Find first visible stroke
      const visibleStroke = node.strokes.find(s => s.visible !== false)
      if (!visibleStroke || visibleStroke.type !== 'SOLID') {
        return classes
      }
      
      // Detect single-side border based on padding pattern (deterministic)
      let borderSide = null // 'b', 't', 'l', 'r', or null for all sides
      
      if (node.autolayout?.padding) {
        const p = node.autolayout.padding
        const hasTop = p.t > 0
        const hasBottom = p.b > 0
        const hasLeft = p.l > 0
        const hasRight = p.r > 0
        
        // Side with no padding = border on that side
        if (!hasTop && hasBottom && hasLeft && hasRight) {
          borderSide = 'b' // bottom border (horizontal tabs)
        } else if (hasTop && !hasBottom && hasLeft && hasRight) {
          borderSide = 't' // top border
        } else if (hasTop && hasBottom && !hasLeft && hasRight) {
          borderSide = 'r' // right border (vertical tabs/sidebar)
        } else if (hasTop && hasBottom && hasLeft && !hasRight) {
          borderSide = 'l' // left border (vertical tabs/sidebar)
        }
      }
      
      // Add border width with appropriate side
      const strokeWeight = node.strokeWeight || 1
      if (typeof strokeWeight === 'number' && strokeWeight > 0) {
        const weight = Math.round(strokeWeight)
        if (borderSide) {
          classes.push(`border-${borderSide}-[${weight}px]`)
        } else {
          classes.push(`border-[${weight}px]`)
        }
      }
      
      // Add border color with appropriate side
      if (visibleStroke.color) {
        const color = visibleStroke.color
        
        // Check for token
        if (tokens && tokens.used) {
          for (const token of tokens.used) {
            if (colorsMatch(color, token.value)) {
              if (borderSide) {
                classes.push(`border-${borderSide}-[var(--${token.name})]`)
              } else {
                classes.push(`border-[var(--${token.name})]`)
              }
              return classes
            }
          }
        }
        
        if (borderSide) {
          classes.push(`border-${borderSide}-[${color}]`)
        } else {
          classes.push(`border-[${color}]`)
        }
      }
      
      return classes
    }

    function getCornerRadiusClass(node) {
      if (!node.cornerRadius && typeof node.cornerRadius !== 'number') return null
      
      const radius = Math.round(node.cornerRadius)
      
      if (radius === 0) return null
      
      // Use standard Tailwind values when possible
      if (radius === 4) return 'rounded'
      if (radius === 6) return 'rounded-md'
      if (radius === 8) return 'rounded-lg'
      if (radius === 12) return 'rounded-xl'
      if (radius === 16) return 'rounded-2xl'
      if (radius === 9999) return 'rounded-full'
      
      return `rounded-[${radius}px]`
    }

    function getEffectClasses(node, issues) {
      const classes = []
      
      if (!node.effects || !Array.isArray(node.effects) || node.effects.length === 0) {
        return classes
      }
      
      // Filter for visible DROP_SHADOW effects only
      const dropShadows = node.effects.filter(e => 
        e.type === 'DROP_SHADOW' && e.visible !== false
      )
      
      if (dropShadows.length === 0) return classes
      
      // If more than 2 shadows, flag as complex and provide raw data
      if (dropShadows.length > 2) {
        issues.push(`Multiple shadows (${dropShadows.length}) on "${node.name}" - raw effects data provided for LLM`)
        return classes
      }
      
      // Try to match common Tailwind shadow presets for single shadow
      if (dropShadows.length === 1) {
        const shadow = dropShadows[0]
        const matchedPreset = matchTailwindShadow(shadow)
        if (matchedPreset) {
          classes.push(matchedPreset)
          return classes
        }
      }
      
      // For 1-2 shadows that don't match presets, create arbitrary shadow value
      // Format: shadow-[x_y_blur_spread_color]
      const shadowValues = dropShadows.map(s => {
        const x = Math.round(s.offset?.x || 0)
        const y = Math.round(s.offset?.y || 0)
        const blur = Math.round(s.radius || 0)
        const spread = Math.round(s.spread || 0)
        const color = s.color || '#000000'
        const opacity = s.opacity !== undefined ? s.opacity : 1
        
        // Convert opacity to rgba if needed
        let colorValue = color
        if (opacity < 1) {
          // Convert hex to rgba with opacity
          const hex = color.replace('#', '')
          const r = parseInt(hex.substring(0, 2), 16)
          const g = parseInt(hex.substring(2, 4), 16)
          const b = parseInt(hex.substring(4, 6), 16)
          colorValue = `rgba(${r},${g},${b},${opacity})`
        }
        
        return `${x}px_${y}px_${blur}px_${spread}px_${colorValue}`
      })
      
      // Join multiple shadows with comma
      classes.push(`shadow-[${shadowValues.join(',')}]`)
      
      return classes
    }

    function matchTailwindShadow(shadow) {
      const x = Math.round(shadow.offset?.x || 0)
      const y = Math.round(shadow.offset?.y || 0)
      const blur = Math.round(shadow.radius || 0)
      const spread = Math.round(shadow.spread || 0)
      
      // Tailwind shadow presets (approximations)
      // shadow-sm: 0 1px 2px 0 rgba(0, 0, 0, 0.05)
      if (x === 0 && y === 1 && blur === 2 && spread === 0) return 'shadow-sm'
      
      // shadow (default): 0 1px 3px 0 rgba(0, 0, 0, 0.1), 0 1px 2px -1px rgba(0, 0, 0, 0.1)
      if (x === 0 && y === 1 && blur === 3 && spread === 0) return 'shadow'
      
      // shadow-md: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -2px rgba(0, 0, 0, 0.1)
      if (x === 0 && y === 4 && blur === 6 && spread === -1) return 'shadow-md'
      
      // shadow-lg: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -4px rgba(0, 0, 0, 0.1)
      if (x === 0 && y === 10 && blur === 15 && spread === -3) return 'shadow-lg'
      
      // shadow-xl: 0 20px 25px -5px rgba(0, 0, 0, 0.1), 0 8px 10px -6px rgba(0, 0, 0, 0.1)
      if (x === 0 && y === 20 && blur === 25 && spread === -5) return 'shadow-xl'
      
      // shadow-2xl: 0 25px 50px -12px rgba(0, 0, 0, 0.25)
      if (x === 0 && y === 25 && blur === 50 && spread === -12) return 'shadow-2xl'
      
      return null // No match
    }

    function colorsMatch(color1, color2) {
      // Simple string comparison for now
      return color1 === color2
    }

    // ========== PREPROCESSOR TEST VIEW ==========
    
    async function showPreprocessorResult() {
      const jsonEl = document.getElementById('json')
      if (!jsonEl) return
      
      if (!state.selectionData || state.selectionData.length === 0) {
        jsonEl.innerHTML = '<div class="empty-state">No selection. Select a layer in Figma first.</div>'
        return
      }
      
      // Show loading
      jsonEl.innerHTML = '<div class="empty-state">Running preprocessor...</div>'
      
      // Run preprocessor
      const result = await preprocessSelection(state.selectionData, state.tokens, state.elementName)
      
      // Display result as formatted JSON
      const pre = document.createElement('pre')
      pre.textContent = JSON.stringify({
        complexityScore: result.meta?.complexityScore,
        recommendedRoute: result.meta?.recommendedRoute,
        issues: result.meta?.issues,
        draftSchema: result.draftSchema,
        componentProperties: state.selectionData[0]?.componentProperties,
        availableVariants: state.selectionData[0]?.availableVariants
      }, null, 2)
      pre.style.cssText = 'font-family:monospace; font-size:11px; padding:12px; margin:0; white-space:pre-wrap;'
      
      jsonEl.innerHTML = ''
      jsonEl.appendChild(pre)
    }

    async function saveTestData() {
      const statusEl = document.getElementById('testCaseStatus')
      const btn = document.getElementById('saveTestDataBtn')
      
      // If no test case exists yet, create one from current selection
      if (!state.lastTestCase) {
        if (!state.selectionData || state.selectionData.length === 0) {
          if (statusEl) statusEl.textContent = '⚠️ No selection to save. Select something in Figma first.'
          setTimeout(() => { if (statusEl) statusEl.textContent = '' }, 3000)
          return
        }
        
        try {
          // Clone and strip large base64 data
          const dataToSend = JSON.parse(JSON.stringify(state.selectionData))
          dataToSend.forEach(node => stripBase64Data(node))
          const strippedSize = JSON.stringify(dataToSend).length
          
          // Run preprocessing
          let preprocessMode = state.preprocessing.enabled ? state.preprocessing.mode : 'off'
          let preprocessingPayload = {
            enabled: false,
            mode: 'off',
            draftSchema: null,
            meta: null
          }
          
          if (preprocessMode !== 'off') {
            const preprocessResult = await preprocessSelection(dataToSend, state.tokens, state.elementName)
            if (preprocessResult.success) {
              if (preprocessMode === 'auto' && preprocessResult.meta.recommendedRoute === 'raw') {
                preprocessingPayload = {
                  enabled: false,
                  mode: 'off',
                  draftSchema: null,
                  meta: preprocessResult.meta
                }
              } else {
                preprocessingPayload = {
                  enabled: true,
                  mode: preprocessMode,
                  draftSchema: preprocessResult.draftSchema,
                  meta: preprocessResult.meta
                }
              }
            }
          }
          
          // Create test case without API response
          state.lastTestCase = {
            timestamp: new Date().toISOString(),
            elementName: state.elementName,
            source: {
              figmaData: JSON.parse(JSON.stringify(state.selectionData)),
              tokens: state.tokens
            },
            preprocessorResult: preprocessingPayload.enabled ? {
              draftSchema: preprocessingPayload.draftSchema,
              meta: preprocessingPayload.meta
            } : null,
            request: {
              type: state.sendAs,
              elementName: state.elementName,
              dataSize: strippedSize,
              preprocessing: preprocessingPayload
            },
            response: null,
            note: 'Saved without LLM response'
          }
        } catch (e) {
          if (statusEl) statusEl.textContent = `⚠️ Error: ${e.message}`
          setTimeout(() => { if (statusEl) statusEl.textContent = '' }, 3000)
          return
        }
      }
      
      // Now save the test case (whether it was just created or already existed)
      const safeName = (state.lastTestCase.elementName || 'test')
        .toLowerCase()
        .replace(/[^a-z0-9]+/g, '_')
        .substring(0, 30)
      const timestamp = new Date().toISOString().replace(/[:.]/g, '-').substring(0, 19)
      const filename = `testcase_${safeName}_${timestamp}.json`
      
      // Download as JSON file
      const jsonString = JSON.stringify(state.lastTestCase, null, 2)
      const blob = new Blob([jsonString], { type: 'application/json' })
      const url = URL.createObjectURL(blob)
      const a = document.createElement('a')
      a.href = url
      a.download = filename
      document.body.appendChild(a)
      a.click()
      document.body.removeChild(a)
      URL.revokeObjectURL(url)
      
      // Show status based on whether we have LLM response
      const hasLLMResponse = state.lastTestCase.response !== null
      const statusMsg = hasLLMResponse 
        ? `✓ Saved with LLM response as ${filename}`
        : `✓ Saved (no LLM response yet) as ${filename}`
      
      if (statusEl) statusEl.textContent = statusMsg
      if (btn) {
        btn.textContent = '✓ Saved!'
        setTimeout(() => {
          btn.textContent = '💾 Save Test Data'
          if (statusEl) statusEl.textContent = ''
        }, 3000)
      }
    }

    // Recursively strip large base64 data to reduce payload size
    function stripBase64Data(node) {
      if (!node || typeof node !== 'object') return node
      
      // Remove large preview image (can be 200-400KB), but keep thumbnail
      if (node.previewUrl && node.previewUrl.startsWith('data:image/')) {
        delete node.previewUrl
      }
      
      // Keep thumbnailUrl - server needs this!
      // Strip SVGs based on user setting
      if (node.svg) {
        if (state.stripAllSvg) {
          // Strip all SVGs if setting is enabled
          node.svg = '[SVG_STRIPPED_BY_USER_SETTING]'
        } else if (node.svg.length > 30000) {
          // Default: only strip SVGs larger than 30KB
          node.svg = '[SVG_STRIPPED_FOR_SIZE]'
        }
      }
      
      // Recursively process children
      if (Array.isArray(node.children)) {
        node.children.forEach(child => stripBase64Data(child))
      }
      
      return node
    }

    async function sendToBetterForms() {
      if (!state.apiKey) {
        showFeedback('Please save an API key in the Account tab first.', 'error')
        return
      }
      if (!state.selectionData || state.selectionData.length === 0) {
        showFeedback('No selection to send.', 'error')
        return
      }
      state.sending = true
      renderSendButton()
      renderSendOptions()
      clearFeedback()
      try {
        // Clone and strip large base64 data to reduce payload size
        const originalSize = JSON.stringify(state.selectionData).length
        const dataToSend = JSON.parse(JSON.stringify(state.selectionData))
        dataToSend.forEach(node => stripBase64Data(node))
        const strippedSize = JSON.stringify(dataToSend).length
        
        // Determine preprocessing mode
        let preprocessMode = 'off'
        if (state.preprocessing.enabled) {
          preprocessMode = state.preprocessing.mode // 'auto', 'on', or 'off'
        }
        
        // Run preprocessing if enabled
        let preprocessingPayload = {
          enabled: false,
          mode: 'off',
          draftSchema: null,
          meta: null
        }
        
        if (preprocessMode !== 'off') {
          const preprocessResult = await preprocessSelection(dataToSend, state.tokens, state.elementName)
          
          if (preprocessResult.success) {
            // For 'auto' mode, use the recommended route
            if (preprocessMode === 'auto' && preprocessResult.meta.recommendedRoute === 'raw') {
              preprocessingPayload = {
                enabled: false,
                mode: 'off',
                draftSchema: null,
                meta: preprocessResult.meta
              }
            } else {
              // For 'on' mode or 'auto' with low complexity, use draft schema
              preprocessingPayload = {
                enabled: true,
                mode: preprocessMode,
                draftSchema: preprocessResult.draftSchema,
                meta: preprocessResult.meta
              }
            }
          } else {
            console.warn('Preprocessing failed, falling back to raw mode:', preprocessResult.error)
            preprocessingPayload.enabled = false
            preprocessingPayload.mode = 'off'
          }
        }
        
        // 🆕 CAPTURE TEST CASE BEFORE SENDING (so we have it even if API times out)
        state.lastTestCase = {
          timestamp: new Date().toISOString(),
          elementName: state.elementName,
          source: {
            figmaData: JSON.parse(JSON.stringify(state.selectionData)), // original unstripped data
            tokens: state.tokens
          },
          preprocessorResult: preprocessingPayload.enabled ? {
            draftSchema: preprocessingPayload.draftSchema,
            meta: preprocessingPayload.meta
          } : null,
          request: {
            type: state.sendAs,
            elementName: state.elementName,
            dataSize: strippedSize,
            preprocessing: preprocessingPayload
          },
          response: null // Will be populated if API succeeds
        }
        
        const requestId = `req_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`
        
        // Create an AbortController with 5-minute timeout for large LLM processing
        const controller = new AbortController()
        const timeoutId = setTimeout(() => controller.abort(), 300000) // 5 minutes (increased from 3)
        
        let response
        try {
          response = await fetch('https://appdev.fmbetterforms.com/api/v1/figma', {
            method: 'POST',
            headers: { 
              'Content-Type': 'application/json',
              'X-Request-ID': requestId
            },
            body: JSON.stringify({
              apiKey: state.apiKey,
              type: state.sendAs,
              elementName: state.elementName || '',
              data: dataToSend,
              tokens: state.tokens,
              preprocessing: preprocessingPayload,
              requestId: requestId
            }),
            signal: controller.signal
          })
          clearTimeout(timeoutId)
        } catch (fetchError) {
          clearTimeout(timeoutId)
          console.error('❌ Fetch failed [' + requestId + ']:', fetchError)
          if (fetchError.name === 'AbortError') {
            throw new Error('Request timed out after 5 minutes. You can still save the test fixture with preprocessor data using "Save Test Case".')
          }
          throw fetchError
        }
        
        if (!response.ok) {
          let serverMsg = ''
          try {
            const ct = response.headers.get('content-type') || ''
            if (ct.includes('application/json')) {
              const errJson = await response.json()
              serverMsg = errJson && (errJson.message || errJson.error || JSON.stringify(errJson)).toString()
            } else {
              serverMsg = (await response.text()) || ''
            }
          } catch {}
          const hint = (status => {
            if (status === 401) return 'Please check your API key.'
            if (status === 403) return 'You do not have permission to perform this action.'
            if (status === 404) return 'Endpoint not found. Please update the plugin or contact support.'
            if (status === 413) return 'Selection is too large. Try selecting a smaller element or component.'
            if (status === 429) return 'Rate limit exceeded. Please wait and try again.'
            if (status === 422) return 'Validation failed. Ensure your selection is valid.'
            if (status >= 500) return 'The server encountered an error. Try again later.'
            return ''
          })(response.status)
          const msg = [`Server responded with ${response.status} ${response.statusText || ''}`.trim(), serverMsg, hint].filter(Boolean).join(' — ')
          throw new Error(msg)
        }
        const result = await response.json()
        
        // 🆕 UPDATE test case with response (test case was already captured before API call)
        if (state.lastTestCase) {
          state.lastTestCase.response = result
        }
        
        // Build success message with preprocessing info if available
        let successMsg = 'Successfully sent to FM BetterForms!'
        if (result.meta) {
          const details = []
          if (result.meta.preprocessingUsed) {
            details.push('preprocessed')
          }
          if (result.meta.route) {
            details.push(`${result.meta.route} route`)
          }
          if (result.meta.model) {
            details.push(result.meta.model)
          }
          if (details.length > 0) {
            successMsg += ` (${details.join(', ')})`
          }
        }
        
        showFeedback(successMsg, 'success')
      } catch (e) {
        showFeedback(`Failed to send: ${e.message}`, 'error')
      } finally {
        state.sending = false
        renderSendButton()
        renderSendOptions()
      }
    }

    function renderSendButton() {
      const btn = document.getElementById('sendBtn')
      if (!btn) return
      const hasSelection = state.selectionData && state.selectionData.length > 0
      btn.disabled = state.sending || !hasSelection
      const sendIcon = '<svg style="width:14px;height:14px;margin-right:6px;display:inline-block;vertical-align:middle;" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M22 2L11 13M22 2l-7 20-4-9-9-4 20-7z"/></svg>'
      btn.innerHTML = state.sending ? 'Sending...' : sendIcon + 'Send to BetterForms'
    }

    function renderSendOptions() {
      const container = document.getElementById('sendOptions')
      if (!container) return
      container.innerHTML = ''
      // Ensure radios align left and use a tight, consistent gap
      container.style.justifyContent = 'flex-start'
      container.style.gap = '6px'

      const label = document.createElement('label')
      label.textContent = 'Export as:'
      // Override the default .row > label width to keep label tight
      label.style.width = 'auto'
      label.style.marginRight = '6px'
      container.appendChild(label)

      const options = [
        { value: 'element', text: 'element' },
        { value: 'component', text: 'component' },
        { value: 'page', text: 'page' }
      ]
      const disabled = state.sending || !(state.selectionData && state.selectionData.length > 0)

      options.forEach(opt => {
        const wrap = document.createElement('label')
        wrap.style.display = 'inline-flex'
        wrap.style.alignItems = 'center'
        // Avoid the global .row > label width rule so radios are tight
        wrap.style.width = 'auto'
        // Rely on container gap; no extra margin between radios
        wrap.style.marginRight = '0'
        // Tighten spacing between the radio control and its text
        wrap.style.gap = '1px'

        const input = document.createElement('input')
        input.type = 'radio'
        input.name = 'sendAs'
        input.value = opt.value
        input.checked = state.sendAs === opt.value
        input.disabled = disabled
        input.onchange = () => { state.sendAs = opt.value }

        const text = document.createElement('span')
        text.textContent = opt.text

        wrap.appendChild(input)
        wrap.appendChild(text)
        container.appendChild(wrap)
      })
    }

    function showFeedback(message, type) {
      const fb = document.getElementById('sendFeedback')
      if (!fb) return
      fb.textContent = message
      fb.className = `feedback ${type}`
      fb.style.display = 'block'
    }

    function clearFeedback() {
      const fb = document.getElementById('sendFeedback')
      if (fb) fb.style.display = 'none'
    }

    function copyJsonToClipboard() {
      if (!state.selectionData || state.selectionData.length === 0) return
      const jsonString = JSON.stringify(state.selectionData, null, 2)
      
      // Use textarea fallback for Figma plugin environment
      const textarea = document.createElement('textarea')
      textarea.value = jsonString
      textarea.style.position = 'fixed'
      textarea.style.opacity = '0'
      document.body.appendChild(textarea)
      textarea.select()
      
      try {
        document.execCommand('copy')
        const btn = document.getElementById('copyBtn')
        const jsonEl = document.getElementById('json')
        
        // Show animated checkmark
        if (jsonEl) {
          const check = document.createElement('div')
          check.className = 'copy-check'
          check.textContent = '✓'
          jsonEl.appendChild(check)
          
          // Remove after animation completes
          setTimeout(() => {
            check.remove()
          }, 600)
        }
        
        // Update button temporarily
        if (btn) {
          btn.classList.add('copied')
          btn.textContent = '✓ Copied!'
          setTimeout(() => {
            btn.classList.remove('copied')
            btn.textContent = 'Copy JSON'
          }, 2000)
        }
      } catch (err) {
        console.error('Failed to copy:', err)
      } finally {
        document.body.removeChild(textarea)
      }
    }

    function renderSelection(selection) {
      const meta = document.getElementById('selMeta')
      const jsonEl = document.getElementById('json')
      const previewEl = document.getElementById('preview')
      const elementNameInput = document.getElementById('elementName')
      clearFeedback()
      
      if (!Array.isArray(selection) || selection.length === 0) {
        if (meta) meta.textContent = 'No selection'
        if (jsonEl) {
          jsonEl.innerHTML = '<div class="empty-state">Select a layer or object to view JSON data</div>'
        }
        if (previewEl) {
          previewEl.innerHTML = '<div class="empty-state">Select a layer or object to preview</div>'
        }
        if (elementNameInput) {
          elementNameInput.value = ''
          elementNameInput.parentElement.style.display = 'none'
        }
        state.elementName = ''
        renderSendButton()
        renderSendOptions()
        return
      }
      const first = selection[0]
      
      // Always update element name from new selection
      state.elementName = first.name || ''
      if (elementNameInput) {
        elementNameInput.value = state.elementName
        elementNameInput.parentElement.style.display = 'flex'
      }
      
      // Build metadata text with token count
      let metaText = `${selection.length} node(s): ${first.name} (${first.type})`
      if (state.tokens) {
        const totalTokens = Object.keys(state.tokens.all || {}).length
        const usedTokens = (state.tokens.used || []).length
        if (totalTokens > 0) {
          metaText += ` • ${totalTokens} tokens (${usedTokens} bound)`
        } else {
          metaText += ` • No tokens in file`
        }
      }
      
      if (meta) meta.textContent = metaText
      // Render JSON with copy button
      try {
        jsonEl.innerHTML = ''
        jsonEl.style.position = 'relative'
        
        // Copy button
        const copyBtn = document.createElement('button')
        copyBtn.id = 'copyBtn'
        copyBtn.className = 'copy-btn'
        copyBtn.textContent = 'Copy JSON'
        copyBtn.onclick = copyJsonToClipboard
        
        // JSON pre element
        const pre = document.createElement('pre')
        pre.textContent = JSON.stringify(selection, null, 2)
        pre.style.fontFamily = 'ui-monospace, SFMono-Regular, Menlo, monospace'
        pre.style.fontSize = '11px'
        pre.style.background = '#f9fafb'
        pre.style.border = '1px solid #e5e7eb'
        pre.style.borderRadius = '4px'
        pre.style.padding = '8px'
        pre.style.paddingTop = '32px'
        pre.style.margin = '0'
        pre.style.overflowX = 'auto'
        
        jsonEl.appendChild(copyBtn)
        jsonEl.appendChild(pre)
        
        // Handle preview rendering
        if (previewEl) {
          if (first.previewUrl) {
            // We have a preview URL - load the image
            const img = document.createElement('img')
            img.src = first.previewUrl
            img.style.maxWidth = '100%'
            img.style.maxHeight = '100%'
            img.style.width = 'auto'
            img.style.height = 'auto'
            img.style.objectFit = 'contain'
            img.style.display = 'block'
            img.style.margin = 'auto'
            img.style.borderRadius = '4px'
            
            // Replace content with image when loaded
            img.onload = () => {
              previewEl.innerHTML = ''
              previewEl.appendChild(img)
            }
            
            // Handle error
            img.onerror = () => {
              previewEl.innerHTML = '<div class="empty-state">Preview failed to load</div>'
            }
          } else {
            // No preview URL yet - show loading spinner
            previewEl.innerHTML = '<div class="loading-spinner"><div class="spinner"></div><div>Generating preview...</div></div>'
          }
        }
      } catch (e) {
        console.error('Error rendering selection:', e)
        jsonEl.textContent = String(e)
      }

      // Ensure correct tab visibility after content updates
      applyActiveTab()
      renderSendButton()
      renderSendOptions()
      
      // Check token count and show warning if needed
      checkTokenLimit(selection)
    }
    
    async function checkTokenLimit(selection) {
      const warningEl = document.getElementById('tokenWarning')
      if (!warningEl) return
      
      // Clone and strip base64 data (same as what gets sent to API)
      const dataToEstimate = JSON.parse(JSON.stringify(selection))
      dataToEstimate.forEach(node => stripBase64Data(node))
      
      // Estimate tokens on STRIPPED data (what actually gets sent)
      const estimatedTokens = estimateTokenCount(dataToEstimate)
      const svgInfo = countSvgs(dataToEstimate)
      
      // Warning threshold: 75K data tokens (prompt ~35K + data ~75K + output ~25K ≈ 135K, safe from 150K cap)
      if (estimatedTokens > 75000) {
        // Show warning
        const svgTokens = svgInfo.totalSize > 0 ? Math.round(svgInfo.totalSize / 3.5) : 0
        const totalEstimate = estimatedTokens + 35000 + 25000 // Data + prompt + expected output
        
        let warningHtml = `<div style="background:#fef3c7; border:1px solid #fde68a; border-radius:4px; padding:8px; margin-bottom:8px;">
          <div style="font-weight:600; font-size:12px; margin-bottom:4px; color:#92400e;">⚠️ Large Selection (~${totalEstimate.toLocaleString()} tokens estimated)</div>
          <div style="font-size:11px; color:#78350f; line-height:1.4;">May exceed 150K token limit. Consider:`
        
        if (svgInfo.count > 0 && svgTokens > 2000) {
          warningHtml += `<br>• Enable "Strip All SVG" in settings (⋮) to save ~${svgTokens.toLocaleString()} tokens`
        }
        
        warningHtml += `<br>• Export design in smaller parts for best results</div></div>`
        
        warningEl.innerHTML = warningHtml
        warningEl.style.display = 'block'
      } else {
        warningEl.innerHTML = ''
        warningEl.style.display = 'none'
      }
    }

    function setActiveTab(tab) {
      state.activeTab = tab
      applyActiveTab()
    }

    function applyActiveTab() {
      const tabs = document.querySelectorAll('.tab')
      tabs.forEach(t => {
        const isActive = t.dataset.tab === state.activeTab
        t.classList.toggle('active', isActive)
      })
      const panes = document.querySelectorAll('.tabpane')
      panes.forEach(p => {
        const isActive = p.dataset.tab === state.activeTab
        p.classList.toggle('active', isActive)
      })
    }
  </script>
</head>
<body>

  <div class="section" id="devSection">
    <div class="tabs">
      <button class="tab active" data-tab="preview" onclick="setActiveTab('preview')">Preview</button>
      <button class="tab" data-tab="json" onclick="setActiveTab('json')">JSON</button>
      <button class="tab" data-tab="account" style="margin-left:auto" onclick="setActiveTab('account')">Account</button>
    </div>
    <div class="tabpanes">
      <div class="tabpane active" data-tab="preview">
        <div class="tabpane-content" style="padding: 12px;">
          <div style="width:100%; padding:0 0 8px 0; display:flex; gap:8px; align-items:center;">
            <label for="elementName" style="font-weight: 500; color: #374151; white-space: nowrap;">Element Name:</label>
            <input id="elementName" type="text" style="flex:2; min-width: 200px;" placeholder="Element name"  oninput="updateElementName(this.value)" />
          </div>
          <div id="tokenWarning" style="display:none;"></div>
          <div id="preview" style="flex:1; display:flex; align-items:center; justify-content:center;">
            <div class="empty-state">Select a layer or object to preview</div>
          </div>
        </div>
        <div class="tabpane-footer" style="position: sticky; bottom: 0; background: white; border-top: 1px solid #e5e7eb; padding: 8px 12px 12px;">
          <div id="sendOptions" class="row inline" style="margin-bottom:8px; padding-bottom:6px; display:none;"></div>
          <div style="display: flex; gap: 4px; align-items: stretch;">
            <button id="sendBtn" class="primary" style="flex: 1;" onclick="sendToBetterForms()">Send to BetterForms</button>
            <button onclick="openExportModal()" title="Export settings" style="padding: 0; width: 40px; height: 40px; min-height: 40px; flex-shrink: 0; background: white; border: 1px solid #d1d5db; color: #111827; font-size: 20px; line-height: 1; display: flex; align-items: center; justify-content: center; border-radius: 4px; cursor: pointer;">⚙</button>
          </div>
          <div id="sendFeedback" class="feedback" style="display:none;"></div>
        </div>
      </div>
      <div class="tabpane" data-tab="json">
        <div class="tabpane-content" style="flex-direction:column;">
          <div style="padding:8px; border-bottom:1px solid #e5e7eb; display:flex; gap:8px; align-items:center; flex-wrap:wrap;">
            <button onclick="showPreprocessorResult()" style="font-size:11px;">🔬 Test Preprocessor</button>
            <button onclick="saveTestData()" style="font-size:11px;" id="saveTestDataBtn">💾 Save Test Data</button>
            <span id="testCaseStatus" style="font-size:10px; color:#6b7280;"></span>
          </div>
          <div id="json" style="width: 100%; height: 100%; overflow:auto;"></div>
        </div>
      </div>
      <div class="tabpane" data-tab="account">
        <div class="tabpane-content" style="display:block; padding:16px;">
          <div id="accountUnsaved">
            <div style="margin-bottom:16px;">
              <strong style="font-size:13px; display:block; margin-bottom:8px;">Connect to BetterForms</strong>
              <p class="small" style="margin:0 0 12px 0; line-height:1.5;">
                To sync designs with FM BetterForms, you'll need an API key from your BetterForms account.
              </p>
              <p class="small" style="margin:0 0 12px 0; line-height:1.5;">
                <strong>How to get your API key:</strong><br>
                1. Open the FM BetterForms Editor<br>
                2. Go to <strong>Account / Users</strong> tab<br>
                3. Copy your API key
              </p>
            </div>
            <div class="row inline" style="margin-bottom:8px;">
              <input id="apiKey" type="password" placeholder="Paste your BetterForms API key here" />
              <button class="primary" onclick="save()">Save</button>
            </div>
          
          </div>
          <div id="accountSaved" style="display:none;">
            <strong style="font-size:13px; display:block; margin-bottom:8px;">Account</strong>
            <div style="padding:12px; background:#f9fafb; border:1px solid #e5e7eb; border-radius:4px; margin-bottom:12px;">
              <div class="small" style="color:#065f46;">✓ API key connected</div>
            </div>
            <div class="row" style="justify-content:flex-end;">
              <button id="logoutBtn" onclick="logout()">Disconnect</button>
            </div>
          </div>
          
          <!-- Version Info -->
          <div style="margin-top:24px; padding-top:16px; border-top:1px solid #e5e7eb;">
            <div class="small" id="versionFooter" style="color:#9ca3af;"></div>
          </div>
        </div>
      </div>
    </div>
  </div>
  
  <!-- Export Settings Modal -->
  <div id="exportModal" class="modal-overlay" onclick="if(event.target === this) closeExportModal()">
    <div class="modal">
      <div class="modal-header">
        <div class="modal-title">Export Settings</div>
        <button class="modal-close" onclick="closeExportModal()">×</button>
      </div>
      <div class="modal-body">
        <div class="modal-setting">
          <div class="modal-setting-label">
            <strong>Outer Element 100% Width</strong>
            <span class="small">Use full width for outer element (BetterForms controls sizing). Off uses fixed Figma width.</span>
          </div>
          <label class="toggle-switch">
            <input type="checkbox" id="outerElementFullWidthToggle" onchange="toggleOuterElementFullWidth()" checked>
            <span class="toggle-slider"></span>
          </label>
        </div>
        <div class="modal-setting">
          <div class="modal-setting-label">
            <strong>Strip Redundant Child Backgrounds</strong>
            <span class="small">Remove child backgrounds matching parent. Reduces CSS bloat and prevents corner bleed.</span>
          </div>
          <label class="toggle-switch">
            <input type="checkbox" id="stripRedundantChildFillsToggle" onchange="toggleStripRedundantChildFills()" checked>
            <span class="toggle-slider"></span>
          </label>
        </div>
        <div class="modal-setting">
          <div class="modal-setting-label">
            <strong>Apply Overflow Hidden to Rounded</strong>
            <span class="small">Add overflow-hidden to rounded containers. Clips child content at rounded corners.</span>
          </div>
          <label class="toggle-switch">
            <input type="checkbox" id="applyOverflowHiddenToggle" onchange="toggleApplyOverflowHidden()" checked>
            <span class="toggle-slider"></span>
          </label>
        </div>
        <div class="modal-setting">
          <div class="modal-setting-label">
            <strong>Strip All SVG Exports</strong>
            <span class="small">Remove all SVG data (not just >30KB). Reduces payload but removes vector data.</span>
          </div>
          <label class="toggle-switch">
            <input type="checkbox" id="stripAllSvgToggle" onchange="toggleStripAllSvg()">
            <span class="toggle-slider"></span>
          </label>
        </div>
      </div>
    </div>
  </div>
</body>
</html>


